// ============================================
// CONFIGURACI√ìN DE PRISMA
// ============================================
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

// ============================================
// MODELO DE USUARIO (Actualizado)
// ============================================
model User {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  googleId  String   @unique
  email     String   @unique
  name      String
  avatarUrl String?
  bio       String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // ‚úÖ Relaci√≥n existente: Mensajes del muro p√∫blico
  messages  Message[]
  
  // ‚ú® NUEVAS RELACIONES para mensajer√≠a privada
  sentDirectMessages     DirectMessage[] @relation("SentMessages")
  receivedDirectMessages DirectMessage[] @relation("ReceivedMessages")
}

// ============================================
// MENSAJES DEL MURO P√öBLICO (Sin cambios)
// ============================================
model Message {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  text      String
  createdAt DateTime @default(now())

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String @db.ObjectId
}

// ============================================
// ‚ú® NUEVOS MODELOS: MENSAJER√çA PRIVADA
// ============================================

// Conversaci√≥n entre usuarios (1-a-1 o grupos futuros)
model Conversation {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Timestamp del √∫ltimo mensaje (para ordenar conversaciones)
  lastMessageAt DateTime @default(now())
  
  // üîß CORREGIDO: En MongoDB, many-to-many se hace con array de IDs
  // NO usar fields/references en relaciones impl√≠citas
  participantIds String[] @db.ObjectId
  
  // Mensajes dentro de esta conversaci√≥n
  messages DirectMessage[]
  
  // √çndices para optimizar queries
  @@index([lastMessageAt])
  @@index([participantIds])
}

// Mensaje directo (dentro de una conversaci√≥n)
model DirectMessage {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  text      String
  createdAt DateTime @default(now())
  
  // Conversaci√≥n a la que pertenece
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  conversationId String       @db.ObjectId
  
  // Qui√©n envi√≥ el mensaje
  sender   User   @relation("SentMessages", fields: [senderId], references: [id], onDelete: Cascade)
  senderId String @db.ObjectId
  
  // Qui√©n recibe el mensaje (para queries r√°pidas)
  receiver   User   @relation("ReceivedMessages", fields: [receiverId], references: [id], onDelete: Cascade)
  receiverId String @db.ObjectId
  
  // Estado de lectura (para futuras features)
  isRead Boolean  @default(false)
  readAt DateTime?
  
  // √çndices para optimizar queries
  @@index([conversationId, createdAt])
  @@index([senderId])
  @@index([receiverId])
}

// ============================================
// NOTAS IMPORTANTES
// ============================================
// 1. Message = Muro p√∫blico (sin cambios)
// 2. DirectMessage = Mensajes privados (nuevo)
// 3. Conversation = Agrupa mensajes privados entre usuarios
// 4. participantIds permite buscar conversaciones eficientemente
// 5. lastMessageAt permite ordenar conversaciones por actividad
//
// Ejecutar despu√©s de guardar:
// npx prisma generate
// npx prisma db push